# **APÊNDICES**

---

## **APÊNDICE A - ROTEIRO DE TESTES DE USABILIDADE**

### **A.1 Protocolo de teste**

#### **Objetivos do teste**

- Avaliar a usabilidade da interface do sistema
- Identificar pontos de dificuldade na navegação
- Coletar feedback sobre funcionalidades implementadas
- Validar fluxos de trabalho principais

#### **Perfil dos participantes**

- **Professores:** 4 participantes (2 homens, 2 mulheres)

  - Idade: 28-45 anos
  - Experiência com tecnologia: básica a intermediária
  - Experiência com aulas particulares: mínimo 2 anos

- **Alunos:** 4 participantes (2 homens, 2 mulheres)
  - Idade: 16-22 anos
  - Experiência com tecnologia: intermediária a avançada
  - Estudantes do ensino médio ou superior

#### **Ambiente de teste**

- Local: Laboratório de usabilidade
- Dispositivo: Tablet Android 10"
- Tempo total: 50 minutos por participante
- Gravação: Tela e áudio (com consentimento)

#### **Estrutura da sessão**

**1. Briefing inicial (5 minutos)**

- Apresentação do pesquisador
- Explicação do objetivo do teste
- Termo de consentimento
- Instruções gerais

**2. Tarefas dirigidas (20 minutos)**

- Execução de tarefas específicas
- Observação e anotações
- Questionamentos pontuais

**3. Uso livre (10 minutos)**

- Exploração livre do sistema
- Observação de comportamentos naturais
- Identificação de funcionalidades descobertas

**4. Questionário de satisfação (5 minutos)**

- Avaliação quantitativa em escala Likert
- Questões sobre aspectos específicos
- Avaliação geral do sistema

**5. Entrevista final (10 minutos)**

- Discussão sobre experiência
- Sugestões de melhoria
- Comentários adicionais

### **A.2 Tarefas para professores**

#### **Tarefa 1: Login no sistema**

**Objetivo:** Verificar facilidade de acesso inicial

**Cenário:** "Você é professor e vai usar o sistema pela primeira vez. Faça login com suas credenciais."

**Dados fornecidos:**

- Email: professor@teste.com
- Senha: 123456

**Critérios de sucesso:**

- Consegue localizar campos de login
- Insere dados corretamente
- Acessa dashboard principal

**Métricas coletadas:**

- Tempo para completar tarefa
- Número de tentativas
- Dificuldades encontradas

#### **Tarefa 2: Cadastrar novo aluno**

**Objetivo:** Avaliar fluxo de cadastro de usuário

**Cenário:** "Um novo aluno quer estudar com você. Cadastre-o no sistema."

**Dados fornecidos:**

- Nome: João Silva Santos
- Email: joao.santos@email.com
- Série: 3º ano do ensino médio

**Critérios de sucesso:**

- Navega para tela de cadastro
- Preenche formulário corretamente
- Confirma cadastro com sucesso

**Métricas coletadas:**

- Tempo para localizar função
- Tempo total de cadastro
- Erros de preenchimento

#### **Tarefa 3: Criar postagem com imagem**

**Objetivo:** Testar funcionalidade principal de comunicação

**Cenário:** "Você quer compartilhar exercícios de matemática com seus alunos. Crie uma postagem incluindo uma foto dos exercícios."

**Dados fornecidos:**

- Matéria: Matemática
- Conteúdo: "Exercícios de álgebra para próxima aula"
- Imagem: Fornecida pelo pesquisador

**Critérios de sucesso:**

- Acessa criação de postagem
- Preenche campos obrigatórios
- Adiciona imagem com sucesso
- Seleciona destinatários
- Publica postagem

**Métricas coletadas:**

- Facilidade de navegação
- Compreensão dos campos
- Sucesso no upload de imagem

#### **Tarefa 4: Agendar aula no cronograma**

**Objetivo:** Validar sistema de agendamento

**Cenário:** "Agende uma aula de física para quarta-feira às 14:00 com um dos seus alunos."

**Dados fornecidos:**

- Dia: Quarta-feira
- Horário: 14:00
- Matéria: Física
- Aluno: Qualquer da lista

**Critérios de sucesso:**

- Acessa cronograma
- Seleciona dia e horário
- Preenche informações da aula
- Confirma agendamento

**Métricas coletadas:**

- Intuitividade da interface
- Clareza do processo
- Validação de conflitos

#### **Tarefa 5: Visualizar lista de alunos**

**Objetivo:** Testar navegação e visualização de dados

**Cenário:** "Você quer ver todos os seus alunos cadastrados. Encontre essa informação."

**Critérios de sucesso:**

- Localiza seção de alunos
- Visualiza lista completa
- Compreende informações exibidas

**Métricas coletadas:**

- Facilidade de localização
- Satisfação com layout
- Compreensão das informações

### **A.3 Tarefas para alunos**

#### **Tarefa 1: Login no sistema**

**Objetivo:** Verificar facilidade de acesso

**Cenário:** "Você vai acessar o sistema para ver materiais do seu professor. Faça login."

**Dados fornecidos:**

- Email: aluno@teste.com
- Senha: 123456

**Critérios similares aos professores**

#### **Tarefa 2: Visualizar postagens por matéria**

**Objetivo:** Testar organização de conteúdo

**Cenário:** "Você quer ver os materiais de matemática que seu professor postou. Encontre essas informações."

**Critérios de sucesso:**

- Localiza seção de postagens
- Identifica organização por matéria
- Acessa conteúdo específico

#### **Tarefa 3: Abrir documento anexado**

**Objetivo:** Validar sistema de anexos

**Cenário:** "Seu professor anexou um documento PDF em uma postagem. Abra esse documento."

**Critérios de sucesso:**

- Identifica anexo na postagem
- Consegue abrir/visualizar documento
- Compreende o conteúdo

#### **Tarefa 4: Consultar cronograma da semana**

**Objetivo:** Testar visualização de cronograma

**Cenário:** "Você quer saber quando são suas próximas aulas. Consulte seu cronograma."

**Critérios de sucesso:**

- Acessa cronograma
- Visualiza aulas agendadas
- Compreende informações exibidas

#### **Tarefa 5: Navegar entre seções**

**Objetivo:** Avaliar navegação geral

**Cenário:** "Explore o aplicativo livremente e mostre as principais seções disponíveis."

**Critérios de sucesso:**

- Utiliza menu de navegação
- Acessa diferentes seções
- Demonstra compreensão da estrutura

### **A.4 Questionário de satisfação**

#### **Escala de avaliação**

1 = Muito insatisfeito
2 = Insatisfeito
3 = Neutro
4 = Satisfeito
5 = Muito satisfeito

#### **Questões aplicadas**

**1. Facilidade de uso geral**
"Como você avalia a facilidade de uso do sistema?"
[ ] 1 [ ] 2 [ ] 3 [ ] 4 [ ] 5

**2. Design e aparência**
"Como você avalia o design e aparência do aplicativo?"
[ ] 1 [ ] 2 [ ] 3 [ ] 4 [ ] 5

**3. Velocidade e responsividade**
"Como você avalia a velocidade do sistema?"
[ ] 1 [ ] 2 [ ] 3 [ ] 4 [ ] 5

**4. Organização das informações**
"Como você avalia a organização das informações?"
[ ] 1 [ ] 2 [ ] 3 [ ] 4 [ ] 5

**5. Utilidade para seu contexto**
"Quão útil seria este sistema para suas atividades educacionais?"
[ ] 1 [ ] 2 [ ] 3 [ ] 4 [ ] 5

**6. Satisfação geral**
"Qual sua satisfação geral com o sistema?"
[ ] 1 [ ] 2 [ ] 3 [ ] 4 [ ] 5

#### **Questões abertas**

**7. Aspecto mais positivo**
"Qual aspecto do sistema você considera mais positivo?"

**8. Principal dificuldade**
"Qual foi sua principal dificuldade ao usar o sistema?"

**9. Sugestão de melhoria**
"Que melhoria você sugeriria para o sistema?"

**10. Recomendação**
"Você recomendaria este sistema para outros professores/alunos? Por quê?"

### **A.5 Critérios de análise**

#### **Métricas quantitativas**

- **Taxa de sucesso:** Percentual de tarefas completadas com sucesso
- **Tempo de execução:** Tempo médio para completar cada tarefa
- **Número de erros:** Quantidade de erros cometidos durante execução
- **Tempo para primeiro clique:** Tempo até primeira interação em cada tarefa
- **Número de cliques:** Quantidade de interações necessárias

#### **Métricas qualitativas**

- **Facilidade de aprendizado:** Capacidade de executar tarefas na primeira tentativa
- **Eficiência:** Capacidade de executar tarefas rapidamente após aprendizado
- **Satisfação subjetiva:** Avaliação geral da experiência
- **Tolerância a erros:** Capacidade de se recuperar de erros
- **Memorabilidade:** Capacidade de lembrar como usar após período sem uso

#### **Critérios de aceitação**

- **Taxa de sucesso mínima:** 80% para tarefas básicas
- **Tempo máximo aceitável:** 3 minutos para tarefas complexas
- **Satisfação mínima:** Média 3,5 na escala Likert
- **Taxa de erro máxima:** 15% em tarefas críticas

---

## **APÊNDICE B - MODELAGEM DETALHADA DO BANCO DE DADOS**

### **B.1 Estrutura do Firestore**

#### **Coleção: users**

```json
{
  "userId": {
    "nome": "string",
    "email": "string",
    "tipo": "professor|aluno",
    "ativo": "boolean",
    "dataCriacao": "timestamp",
    "ultimoAcesso": "timestamp"
  }
}
```

#### **Coleção: professores**

```json
{
  "professorId": {
    "userId": "string (referência para users)",
    "especialidades": ["string"],
    "biografia": "string",
    "telefone": "string",
    "endereco": {
      "rua": "string",
      "numero": "string",
      "bairro": "string",
      "cidade": "string",
      "cep": "string"
    },
    "configuracoes": {
      "notificacoes": "boolean",
      "publico": "boolean"
    },
    "estatisticas": {
      "totalAlunos": "number",
      "totalPostagens": "number",
      "dataUltimaPostagem": "timestamp"
    }
  }
}
```

#### **Coleção: alunos**

```json
{
  "alunoId": {
    "userId": "string (referência para users)",
    "serie": "string",
    "escola": "string",
    "responsavel": {
      "nome": "string",
      "telefone": "string",
      "email": "string"
    },
    "professoresAssociados": ["string"],
    "materias": ["string"],
    "configuracoes": {
      "notificacoes": "boolean",
      "lembretes": "boolean"
    }
  }
}
```

#### **Coleção: postagens**

```json
{
  "postagemId": {
    "professorId": "string",
    "materia": "string",
    "titulo": "string",
    "conteudo": "string",
    "alunosDestino": ["string"],
    "dataPostagem": "timestamp",
    "imagensBase64": ["string"],
    "documentos": [
      {
        "nome": "string",
        "tipo": "string",
        "tamanho": "number",
        "conteudoBase64": "string",
        "dataUpload": "timestamp"
      }
    ],
    "ativo": "boolean",
    "visualizacoes": [
      {
        "alunoId": "string",
        "dataVisualizacao": "timestamp"
      }
    ]
  }
}
```

#### **Coleção: aulas**

```json
{
  "aulaId": {
    "professorId": "string",
    "alunoId": "string",
    "diaSemana": "number (0-6)",
    "horario": "string (HH:mm)",
    "titulo": "string",
    "materia": "string",
    "duracao": "number (minutos)",
    "local": "string",
    "observacoes": "string",
    "ativo": "boolean",
    "dataCriacao": "timestamp"
  }
}
```

### **B.4 Detalhamento técnico do armazenamento Base64**

#### **Fundamentos da codificação Base64**

Base64 é um esquema de codificação que converte dados binários em representação ASCII usando 64 caracteres imprimíveis (A-Z, a-z, 0-9, +, /). No contexto do projeto:

**Processo de codificação:**

1. **Input:** Arquivo binário (imagem JPG, documento PDF)
2. **Conversão:** Bytes convertidos para string Base64
3. **Armazenamento:** String salva diretamente no documento Firestore
4. **Recuperação:** String decodificada de volta para bytes originais

#### **Implementação específica no projeto**

```dart
// Processo completo de upload de imagem
Future<bool> processarImagem(XFile imagemFile) async {
  try {
    // 1. Leitura do arquivo
    final bytes = await imagemFile.readAsBytes();

    // 2. Validação de tamanho (max 5MB)
    if (bytes.length > 5 * 1024 * 1024) {
      throw Exception('Arquivo muito grande');
    }

    // 3. Compressão (se necessário)
    final bytesOtimizados = await _comprimirSeNecessario(bytes);

    // 4. Codificação Base64
    final base64String = base64Encode(bytesOtimizados);

    // 5. Armazenamento no Firestore
    await _firestore.collection('postagens').add({
      'conteudo': 'Texto da postagem',
      'imagensBase64': [base64String],
      'timestamp': FieldValue.serverTimestamp(),
    });

    return true;
  } catch (e) {
    print('Erro no processamento: $e');
    return false;
  }
}

// Processo de recuperação e exibição
Widget exibirImagem(String base64String) {
  try {
    // Decodificação Base64 para bytes
    final bytes = base64Decode(base64String);

    // Exibição direta na interface
    return Image.memory(
      bytes,
      fit: BoxFit.cover,
      errorBuilder: (context, error, stackTrace) {
        return Icon(Icons.error, color: Colors.red);
      },
    );
  } catch (e) {
    return Icon(Icons.broken_image, color: Colors.grey);
  }
}
```

#### **Análise comparativa: Base64 vs Firebase Storage**

| **Aspecto**             | **Base64 (Escolhido)**   | **Firebase Storage** |
| ----------------------- | ------------------------ | -------------------- |
| **Complexidade**        | Baixa (1 serviço)        | Média (2 serviços)   |
| **Consistência**        | Atômica                  | Eventual             |
| **Overhead**            | +33% tamanho             | URLs pequenas        |
| **Cache**               | Automático (Firestore)   | Manual (CDN)         |
| **Limite tamanho**      | 1MB por documento        | 5TB por arquivo      |
| **Velocidade upload**   | Rápida (direto)          | Média (2 etapas)     |
| **Velocidade download** | Lenta (dados grandes)    | Rápida (CDN)         |
| **Backup**              | Integrado                | Separado             |
| **Custo**               | Incluído no Firestore    | Adicional            |
| **Adequação**           | Arquivos pequenos/médios | Arquivos grandes     |

#### **Otimizações implementadas**

**1. Compressão automática de imagens:**

```dart
Future<Uint8List> _comprimirImagem(Uint8List bytes) async {
  if (bytes.length <= 1024 * 1024) return bytes; // < 1MB: não comprimir

  return await FlutterImageCompress.compressWithList(
    bytes,
    quality: 85, // Qualidade balanceada
    maxWidth: 1920, // Full HD máximo
    maxHeight: 1920,
    format: CompressFormat.jpeg, // Força JPEG (menor)
  );
}
```

**2. Validação de tamanho progressiva:**

```dart
bool _validarTamanhoDocumento(List<String> imagens, List<DocumentoModel> docs) {
  double tamanhoTotal = 0;

  // Calcular tamanho das imagens (Base64 overhead ~33%)
  for (final base64 in imagens) {
    tamanhoTotal += base64.length / (1024 * 1024);
  }

  // Calcular tamanho dos documentos
  for (final doc in docs) {
    tamanhoTotal += (doc.conteudoBase64.length / (1024 * 1024));
  }

  return tamanhoTotal <= 0.8; // 80% do limite Firestore (1MB)
}
```

**3. Estratégia de fallback:**

```dart
Future<void> salvarPostagem(PostagemModel postagem) async {
  try {
    // Tentar salvar com todos os anexos
    await _firestore.collection('postagens').add(postagem.toMap());
  } catch (e) {
    if (e.toString().contains('document too large')) {
      // Fallback: reduzir qualidade das imagens
      final postagemOtimizada = await _otimizarAnexos(postagem);
      await _firestore.collection('postagens').add(postagemOtimizada.toMap());
    } else {
      rethrow;
    }
  }
}
```

#### **Justificativa da escolha no contexto educacional**

**1. Simplicidade arquitetural priorizada:**
Em ambiente acadêmico/educacional, a simplicidade de desenvolvimento e manutenção supera otimizações de performance para casos de uso específicos.

**2. Volume de dados adequado:**
Aulas particulares geram volume limitado de anexos (exercícios, imagens de quadro, PDFs pequenos), adequado às limitações do Base64.

**3. Facilidade de backup e migração:**
Instituições educacionais valorizam facilidade de backup completo e migração de dados, favorecendo abordagem integrada.

**4. Redução de dependências:**
Menor número de serviços externos reduz pontos de falha e simplifica configuração para novos desenvolvedores.

### **B.2 Índices do Firestore**

#### **Índices compostos necessários**

**postagens:**

- professorId (ASC) + ativo (ASC) + dataPostagem (DESC)
- alunosDestino (ARRAY) + ativo (ASC) + dataPostagem (DESC)
- materia (ASC) + alunosDestino (ARRAY) + dataPostagem (DESC)

**aulas:**

- professorId (ASC) + ativo (ASC) + diaSemana (ASC)
- alunoId (ASC) + ativo (ASC) + diaSemana (ASC)
- professorId (ASC) + diaSemana (ASC) + horario (ASC)

**users:**

- tipo (ASC) + ativo (ASC) + dataCriacao (DESC)
- email (ASC) + ativo (ASC)

### **B.3 Regras de validação**

#### **Validações de dados**

**Usuários:**

- Nome: obrigatório, mínimo 2 caracteres
- Email: formato válido, único no sistema
- Tipo: apenas "professor" ou "aluno"

**Postagens:**

- Conteúdo: obrigatório, máximo 5000 caracteres
- Matéria: obrigatória, lista pré-definida
- Destinatários: pelo menos um aluno

**Aulas:**

- Dia da semana: 0-6 (domingo a sábado)
- Horário: formato HH:mm válido
- Conflitos: não permitir sobreposição

#### **Validações de negócio**

**Relacionamentos:**

- Professor pode ter múltiplos alunos
- Aluno pode ter múltiplos professores
- Postagem deve ter destinatários válidos
- Aula deve ter participantes válidos

**Permissões:**

- Professor: CRUD em suas postagens e aulas
- Aluno: READ em postagens destinadas a ele
- Aluno: READ em aulas que participa

---

## **APÊNDICE C - CÓDIGO FONTE COMPLETO DOS MODELS**

### **C.1 UserModel**

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

enum TipoUsuario { professor, aluno }

class UserModel {
  final String id;
  final String nome;
  final String email;
  final TipoUsuario tipo;
  final bool ativo;
  final DateTime dataCriacao;
  final DateTime? ultimoAcesso;

  UserModel({
    required this.id,
    required this.nome,
    required this.email,
    required this.tipo,
    this.ativo = true,
    required this.dataCriacao,
    this.ultimoAcesso,
  });

  // Converter de Map (Firestore) para UserModel
  factory UserModel.fromMap(Map<String, dynamic> map, String documentId) {
    return UserModel(
      id: documentId,
      nome: map['nome'] ?? '',
      email: map['email'] ?? '',
      tipo: _stringToTipoUsuario(map['tipo'] ?? 'aluno'),
      ativo: map['ativo'] ?? true,
      dataCriacao: (map['dataCriacao'] as Timestamp).toDate(),
      ultimoAcesso: map['ultimoAcesso'] != null
          ? (map['ultimoAcesso'] as Timestamp).toDate()
          : null,
    );
  }

  // Converter de UserModel para Map (Firestore)
  Map<String, dynamic> toMap() {
    return {
      'nome': nome,
      'email': email,
      'tipo': _tipoUsuarioToString(tipo),
      'ativo': ativo,
      'dataCriacao': Timestamp.fromDate(dataCriacao),
      'ultimoAcesso': ultimoAcesso != null
          ? Timestamp.fromDate(ultimoAcesso!)
          : null,
    };
  }

  // Converter string para enum
  static TipoUsuario _stringToTipoUsuario(String tipo) {
    switch (tipo.toLowerCase()) {
      case 'professor':
        return TipoUsuario.professor;
      case 'aluno':
        return TipoUsuario.aluno;
      default:
        return TipoUsuario.aluno;
    }
  }

  // Converter enum para string
  static String _tipoUsuarioToString(TipoUsuario tipo) {
    switch (tipo) {
      case TipoUsuario.professor:
        return 'professor';
      case TipoUsuario.aluno:
        return 'aluno';
    }
  }

  // Validar email
  static bool isValidEmail(String email) {
    return RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(email);
  }

  // Validar nome
  static bool isValidName(String nome) {
    return nome.trim().length >= 2;
  }

  // CopyWith para atualizações
  UserModel copyWith({
    String? id,
    String? nome,
    String? email,
    TipoUsuario? tipo,
    bool? ativo,
    DateTime? dataCriacao,
    DateTime? ultimoAcesso,
  }) {
    return UserModel(
      id: id ?? this.id,
      nome: nome ?? this.nome,
      email: email ?? this.email,
      tipo: tipo ?? this.tipo,
      ativo: ativo ?? this.ativo,
      dataCriacao: dataCriacao ?? this.dataCriacao,
      ultimoAcesso: ultimoAcesso ?? this.ultimoAcesso,
    );
  }

  @override
  String toString() {
    return 'UserModel(id: $id, nome: $nome, email: $email, tipo: $tipo)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is UserModel && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}
```

### **C.2 PostagemModel**

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

class DocumentoModel {
  final String nome;
  final String tipo;
  final int tamanho;
  final String conteudoBase64;
  final DateTime dataUpload;

  DocumentoModel({
    required this.nome,
    required this.tipo,
    required this.tamanho,
    required this.conteudoBase64,
    required this.dataUpload,
  });

  factory DocumentoModel.fromMap(Map<String, dynamic> map) {
    return DocumentoModel(
      nome: map['nome'] ?? '',
      tipo: map['tipo'] ?? '',
      tamanho: map['tamanho'] ?? 0,
      conteudoBase64: map['conteudoBase64'] ?? '',
      dataUpload: (map['dataUpload'] as Timestamp).toDate(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'nome': nome,
      'tipo': tipo,
      'tamanho': tamanho,
      'conteudoBase64': conteudoBase64,
      'dataUpload': Timestamp.fromDate(dataUpload),
    };
  }
}

class VisualizacaoModel {
  final String alunoId;
  final DateTime dataVisualizacao;

  VisualizacaoModel({
    required this.alunoId,
    required this.dataVisualizacao,
  });

  factory VisualizacaoModel.fromMap(Map<String, dynamic> map) {
    return VisualizacaoModel(
      alunoId: map['alunoId'] ?? '',
      dataVisualizacao: (map['dataVisualizacao'] as Timestamp).toDate(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'alunoId': alunoId,
      'dataVisualizacao': Timestamp.fromDate(dataVisualizacao),
    };
  }
}

class PostagemModel {
  final String id;
  final String professorId;
  final String materia;
  final String titulo;
  final String conteudo;
  final List<String> alunosDestino;
  final DateTime dataPostagem;
  final List<String> imagensBase64;
  final List<DocumentoModel> documentos;
  final bool ativo;
  final List<VisualizacaoModel> visualizacoes;

  PostagemModel({
    required this.id,
    required this.professorId,
    required this.materia,
    this.titulo = '',
    required this.conteudo,
    required this.alunosDestino,
    required this.dataPostagem,
    this.imagensBase64 = const [],
    this.documentos = const [],
    this.ativo = true,
    this.visualizacoes = const [],
  });

  factory PostagemModel.fromMap(Map<String, dynamic> map, String documentId) {
    return PostagemModel(
      id: documentId,
      professorId: map['professorId'] ?? '',
      materia: map['materia'] ?? '',
      titulo: map['titulo'] ?? '',
      conteudo: map['conteudo'] ?? '',
      alunosDestino: List<String>.from(map['alunosDestino'] ?? []),
      dataPostagem: (map['dataPostagem'] as Timestamp).toDate(),
      imagensBase64: List<String>.from(map['imagensBase64'] ?? []),
      documentos: (map['documentos'] as List<dynamic>?)
          ?.map((doc) => DocumentoModel.fromMap(doc))
          .toList() ?? [],
      ativo: map['ativo'] ?? true,
      visualizacoes: (map['visualizacoes'] as List<dynamic>?)
          ?.map((vis) => VisualizacaoModel.fromMap(vis))
          .toList() ?? [],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'professorId': professorId,
      'materia': materia,
      'titulo': titulo,
      'conteudo': conteudo,
      'alunosDestino': alunosDestino,
      'dataPostagem': Timestamp.fromDate(dataPostagem),
      'imagensBase64': imagensBase64,
      'documentos': documentos.map((doc) => doc.toMap()).toList(),
      'ativo': ativo,
      'visualizacoes': visualizacoes.map((vis) => vis.toMap()).toList(),
    };
  }

  // Verificar se aluno visualizou a postagem
  bool foiVisualizadoPor(String alunoId) {
    return visualizacoes.any((vis) => vis.alunoId == alunoId);
  }

  // Adicionar visualização
  PostagemModel adicionarVisualizacao(String alunoId) {
    if (foiVisualizadoPor(alunoId)) return this;

    final novaVisualizacao = VisualizacaoModel(
      alunoId: alunoId,
      dataVisualizacao: DateTime.now(),
    );

    return copyWith(
      visualizacoes: [...visualizacoes, novaVisualizacao],
    );
  }

  // Quantidade de anexos
  int get totalAnexos => imagensBase64.length + documentos.length;

  // Tamanho total em bytes
  int get tamanhoTotalBytes {
    int total = 0;

    // Aproximação para imagens base64 (75% do tamanho base64)
    for (final base64 in imagensBase64) {
      total += (base64.length * 0.75).round();
    }

    // Documentos
    for (final doc in documentos) {
      total += doc.tamanho;
    }

    return total;
  }

  PostagemModel copyWith({
    String? id,
    String? professorId,
    String? materia,
    String? titulo,
    String? conteudo,
    List<String>? alunosDestino,
    DateTime? dataPostagem,
    List<String>? imagensBase64,
    List<DocumentoModel>? documentos,
    bool? ativo,
    List<VisualizacaoModel>? visualizacoes,
  }) {
    return PostagemModel(
      id: id ?? this.id,
      professorId: professorId ?? this.professorId,
      materia: materia ?? this.materia,
      titulo: titulo ?? this.titulo,
      conteudo: conteudo ?? this.conteudo,
      alunosDestino: alunosDestino ?? this.alunosDestino,
      dataPostagem: dataPostagem ?? this.dataPostagem,
      imagensBase64: imagensBase64 ?? this.imagensBase64,
      documentos: documentos ?? this.documentos,
      ativo: ativo ?? this.ativo,
      visualizacoes: visualizacoes ?? this.visualizacoes,
    );
  }
}
```

---

### 📊 **MÉTRICAS DOS APÊNDICES**

| **Apêndice**               | **Conteúdo**                       | **Palavras**       |
| -------------------------- | ---------------------------------- | ------------------ |
| **A - Testes Usabilidade** | Protocolo completo + questionários | 1.567 palavras     |
| **B - Modelagem BD**       | Estrutura Firestore + validações   | 745 palavras       |
| **C - Código Models**      | Código fonte completo              | 1.234 palavras     |
| **TOTAL APÊNDICES**        | **Documentação técnica detalhada** | **3.546 palavras** |

---

**📄 Continua: Anexos**
