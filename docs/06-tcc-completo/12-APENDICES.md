# **AP√äNDICES**

---

## **AP√äNDICE A - ROTEIRO DE TESTES DE USABILIDADE**

### **A.1 Protocolo de teste**

#### **Objetivos do teste**

- Avaliar a usabilidade da interface do sistema
- Identificar pontos de dificuldade na navega√ß√£o
- Coletar feedback sobre funcionalidades implementadas
- Validar fluxos de trabalho principais

#### **Perfil dos participantes**

- **Professores:** 4 participantes (2 homens, 2 mulheres)

  - Idade: 28-45 anos
  - Experi√™ncia com tecnologia: b√°sica a intermedi√°ria
  - Experi√™ncia com aulas particulares: m√≠nimo 2 anos

- **Alunos:** 4 participantes (2 homens, 2 mulheres)
  - Idade: 16-22 anos
  - Experi√™ncia com tecnologia: intermedi√°ria a avan√ßada
  - Estudantes do ensino m√©dio ou superior

#### **Ambiente de teste**

- Local: Laborat√≥rio de usabilidade
- Dispositivo: Tablet Android 10"
- Tempo total: 50 minutos por participante
- Grava√ß√£o: Tela e √°udio (com consentimento)

#### **Estrutura da sess√£o**

**1. Briefing inicial (5 minutos)**

- Apresenta√ß√£o do pesquisador
- Explica√ß√£o do objetivo do teste
- Termo de consentimento
- Instru√ß√µes gerais

**2. Tarefas dirigidas (20 minutos)**

- Execu√ß√£o de tarefas espec√≠ficas
- Observa√ß√£o e anota√ß√µes
- Questionamentos pontuais

**3. Uso livre (10 minutos)**

- Explora√ß√£o livre do sistema
- Observa√ß√£o de comportamentos naturais
- Identifica√ß√£o de funcionalidades descobertas

**4. Question√°rio de satisfa√ß√£o (5 minutos)**

- Avalia√ß√£o quantitativa em escala Likert
- Quest√µes sobre aspectos espec√≠ficos
- Avalia√ß√£o geral do sistema

**5. Entrevista final (10 minutos)**

- Discuss√£o sobre experi√™ncia
- Sugest√µes de melhoria
- Coment√°rios adicionais

### **A.2 Tarefas para professores**

#### **Tarefa 1: Login no sistema**

**Objetivo:** Verificar facilidade de acesso inicial

**Cen√°rio:** "Voc√™ √© professor e vai usar o sistema pela primeira vez. Fa√ßa login com suas credenciais."

**Dados fornecidos:**

- Email: professor@teste.com
- Senha: 123456

**Crit√©rios de sucesso:**

- Consegue localizar campos de login
- Insere dados corretamente
- Acessa dashboard principal

**M√©tricas coletadas:**

- Tempo para completar tarefa
- N√∫mero de tentativas
- Dificuldades encontradas

#### **Tarefa 2: Cadastrar novo aluno**

**Objetivo:** Avaliar fluxo de cadastro de usu√°rio

**Cen√°rio:** "Um novo aluno quer estudar com voc√™. Cadastre-o no sistema."

**Dados fornecidos:**

- Nome: Jo√£o Silva Santos
- Email: joao.santos@email.com
- S√©rie: 3¬∫ ano do ensino m√©dio

**Crit√©rios de sucesso:**

- Navega para tela de cadastro
- Preenche formul√°rio corretamente
- Confirma cadastro com sucesso

**M√©tricas coletadas:**

- Tempo para localizar fun√ß√£o
- Tempo total de cadastro
- Erros de preenchimento

#### **Tarefa 3: Criar postagem com imagem**

**Objetivo:** Testar funcionalidade principal de comunica√ß√£o

**Cen√°rio:** "Voc√™ quer compartilhar exerc√≠cios de matem√°tica com seus alunos. Crie uma postagem incluindo uma foto dos exerc√≠cios."

**Dados fornecidos:**

- Mat√©ria: Matem√°tica
- Conte√∫do: "Exerc√≠cios de √°lgebra para pr√≥xima aula"
- Imagem: Fornecida pelo pesquisador

**Crit√©rios de sucesso:**

- Acessa cria√ß√£o de postagem
- Preenche campos obrigat√≥rios
- Adiciona imagem com sucesso
- Seleciona destinat√°rios
- Publica postagem

**M√©tricas coletadas:**

- Facilidade de navega√ß√£o
- Compreens√£o dos campos
- Sucesso no upload de imagem

#### **Tarefa 4: Agendar aula no cronograma**

**Objetivo:** Validar sistema de agendamento

**Cen√°rio:** "Agende uma aula de f√≠sica para quarta-feira √†s 14:00 com um dos seus alunos."

**Dados fornecidos:**

- Dia: Quarta-feira
- Hor√°rio: 14:00
- Mat√©ria: F√≠sica
- Aluno: Qualquer da lista

**Crit√©rios de sucesso:**

- Acessa cronograma
- Seleciona dia e hor√°rio
- Preenche informa√ß√µes da aula
- Confirma agendamento

**M√©tricas coletadas:**

- Intuitividade da interface
- Clareza do processo
- Valida√ß√£o de conflitos

#### **Tarefa 5: Visualizar lista de alunos**

**Objetivo:** Testar navega√ß√£o e visualiza√ß√£o de dados

**Cen√°rio:** "Voc√™ quer ver todos os seus alunos cadastrados. Encontre essa informa√ß√£o."

**Crit√©rios de sucesso:**

- Localiza se√ß√£o de alunos
- Visualiza lista completa
- Compreende informa√ß√µes exibidas

**M√©tricas coletadas:**

- Facilidade de localiza√ß√£o
- Satisfa√ß√£o com layout
- Compreens√£o das informa√ß√µes

### **A.3 Tarefas para alunos**

#### **Tarefa 1: Login no sistema**

**Objetivo:** Verificar facilidade de acesso

**Cen√°rio:** "Voc√™ vai acessar o sistema para ver materiais do seu professor. Fa√ßa login."

**Dados fornecidos:**

- Email: aluno@teste.com
- Senha: 123456

**Crit√©rios similares aos professores**

#### **Tarefa 2: Visualizar postagens por mat√©ria**

**Objetivo:** Testar organiza√ß√£o de conte√∫do

**Cen√°rio:** "Voc√™ quer ver os materiais de matem√°tica que seu professor postou. Encontre essas informa√ß√µes."

**Crit√©rios de sucesso:**

- Localiza se√ß√£o de postagens
- Identifica organiza√ß√£o por mat√©ria
- Acessa conte√∫do espec√≠fico

#### **Tarefa 3: Abrir documento anexado**

**Objetivo:** Validar sistema de anexos

**Cen√°rio:** "Seu professor anexou um documento PDF em uma postagem. Abra esse documento."

**Crit√©rios de sucesso:**

- Identifica anexo na postagem
- Consegue abrir/visualizar documento
- Compreende o conte√∫do

#### **Tarefa 4: Consultar cronograma da semana**

**Objetivo:** Testar visualiza√ß√£o de cronograma

**Cen√°rio:** "Voc√™ quer saber quando s√£o suas pr√≥ximas aulas. Consulte seu cronograma."

**Crit√©rios de sucesso:**

- Acessa cronograma
- Visualiza aulas agendadas
- Compreende informa√ß√µes exibidas

#### **Tarefa 5: Navegar entre se√ß√µes**

**Objetivo:** Avaliar navega√ß√£o geral

**Cen√°rio:** "Explore o aplicativo livremente e mostre as principais se√ß√µes dispon√≠veis."

**Crit√©rios de sucesso:**

- Utiliza menu de navega√ß√£o
- Acessa diferentes se√ß√µes
- Demonstra compreens√£o da estrutura

### **A.4 Question√°rio de satisfa√ß√£o**

#### **Escala de avalia√ß√£o**

1 = Muito insatisfeito
2 = Insatisfeito
3 = Neutro
4 = Satisfeito
5 = Muito satisfeito

#### **Quest√µes aplicadas**

**1. Facilidade de uso geral**
"Como voc√™ avalia a facilidade de uso do sistema?"
[ ] 1 [ ] 2 [ ] 3 [ ] 4 [ ] 5

**2. Design e apar√™ncia**
"Como voc√™ avalia o design e apar√™ncia do aplicativo?"
[ ] 1 [ ] 2 [ ] 3 [ ] 4 [ ] 5

**3. Velocidade e responsividade**
"Como voc√™ avalia a velocidade do sistema?"
[ ] 1 [ ] 2 [ ] 3 [ ] 4 [ ] 5

**4. Organiza√ß√£o das informa√ß√µes**
"Como voc√™ avalia a organiza√ß√£o das informa√ß√µes?"
[ ] 1 [ ] 2 [ ] 3 [ ] 4 [ ] 5

**5. Utilidade para seu contexto**
"Qu√£o √∫til seria este sistema para suas atividades educacionais?"
[ ] 1 [ ] 2 [ ] 3 [ ] 4 [ ] 5

**6. Satisfa√ß√£o geral**
"Qual sua satisfa√ß√£o geral com o sistema?"
[ ] 1 [ ] 2 [ ] 3 [ ] 4 [ ] 5

#### **Quest√µes abertas**

**7. Aspecto mais positivo**
"Qual aspecto do sistema voc√™ considera mais positivo?"

**8. Principal dificuldade**
"Qual foi sua principal dificuldade ao usar o sistema?"

**9. Sugest√£o de melhoria**
"Que melhoria voc√™ sugeriria para o sistema?"

**10. Recomenda√ß√£o**
"Voc√™ recomendaria este sistema para outros professores/alunos? Por qu√™?"

### **A.5 Crit√©rios de an√°lise**

#### **M√©tricas quantitativas**

- **Taxa de sucesso:** Percentual de tarefas completadas com sucesso
- **Tempo de execu√ß√£o:** Tempo m√©dio para completar cada tarefa
- **N√∫mero de erros:** Quantidade de erros cometidos durante execu√ß√£o
- **Tempo para primeiro clique:** Tempo at√© primeira intera√ß√£o em cada tarefa
- **N√∫mero de cliques:** Quantidade de intera√ß√µes necess√°rias

#### **M√©tricas qualitativas**

- **Facilidade de aprendizado:** Capacidade de executar tarefas na primeira tentativa
- **Efici√™ncia:** Capacidade de executar tarefas rapidamente ap√≥s aprendizado
- **Satisfa√ß√£o subjetiva:** Avalia√ß√£o geral da experi√™ncia
- **Toler√¢ncia a erros:** Capacidade de se recuperar de erros
- **Memorabilidade:** Capacidade de lembrar como usar ap√≥s per√≠odo sem uso

#### **Crit√©rios de aceita√ß√£o**

- **Taxa de sucesso m√≠nima:** 80% para tarefas b√°sicas
- **Tempo m√°ximo aceit√°vel:** 3 minutos para tarefas complexas
- **Satisfa√ß√£o m√≠nima:** M√©dia 3,5 na escala Likert
- **Taxa de erro m√°xima:** 15% em tarefas cr√≠ticas

---

## **AP√äNDICE B - MODELAGEM DETALHADA DO BANCO DE DADOS**

### **B.1 Estrutura do Firestore**

#### **Cole√ß√£o: users**

```json
{
  "userId": {
    "nome": "string",
    "email": "string",
    "tipo": "professor|aluno",
    "ativo": "boolean",
    "dataCriacao": "timestamp",
    "ultimoAcesso": "timestamp"
  }
}
```

#### **Cole√ß√£o: professores**

```json
{
  "professorId": {
    "userId": "string (refer√™ncia para users)",
    "especialidades": ["string"],
    "biografia": "string",
    "telefone": "string",
    "endereco": {
      "rua": "string",
      "numero": "string",
      "bairro": "string",
      "cidade": "string",
      "cep": "string"
    },
    "configuracoes": {
      "notificacoes": "boolean",
      "publico": "boolean"
    },
    "estatisticas": {
      "totalAlunos": "number",
      "totalPostagens": "number",
      "dataUltimaPostagem": "timestamp"
    }
  }
}
```

#### **Cole√ß√£o: alunos**

```json
{
  "alunoId": {
    "userId": "string (refer√™ncia para users)",
    "serie": "string",
    "escola": "string",
    "responsavel": {
      "nome": "string",
      "telefone": "string",
      "email": "string"
    },
    "professoresAssociados": ["string"],
    "materias": ["string"],
    "configuracoes": {
      "notificacoes": "boolean",
      "lembretes": "boolean"
    }
  }
}
```

#### **Cole√ß√£o: postagens**

```json
{
  "postagemId": {
    "professorId": "string",
    "materia": "string",
    "titulo": "string",
    "conteudo": "string",
    "alunosDestino": ["string"],
    "dataPostagem": "timestamp",
    "imagensBase64": ["string"],
    "documentos": [
      {
        "nome": "string",
        "tipo": "string",
        "tamanho": "number",
        "conteudoBase64": "string",
        "dataUpload": "timestamp"
      }
    ],
    "ativo": "boolean",
    "visualizacoes": [
      {
        "alunoId": "string",
        "dataVisualizacao": "timestamp"
      }
    ]
  }
}
```

#### **Cole√ß√£o: aulas**

```json
{
  "aulaId": {
    "professorId": "string",
    "alunoId": "string",
    "diaSemana": "number (0-6)",
    "horario": "string (HH:mm)",
    "titulo": "string",
    "materia": "string",
    "duracao": "number (minutos)",
    "local": "string",
    "observacoes": "string",
    "ativo": "boolean",
    "dataCriacao": "timestamp"
  }
}
```

### **B.4 Detalhamento t√©cnico do armazenamento Base64**

#### **Fundamentos da codifica√ß√£o Base64**

Base64 √© um esquema de codifica√ß√£o que converte dados bin√°rios em representa√ß√£o ASCII usando 64 caracteres imprim√≠veis (A-Z, a-z, 0-9, +, /). No contexto do projeto:

**Processo de codifica√ß√£o:**

1. **Input:** Arquivo bin√°rio (imagem JPG, documento PDF)
2. **Convers√£o:** Bytes convertidos para string Base64
3. **Armazenamento:** String salva diretamente no documento Firestore
4. **Recupera√ß√£o:** String decodificada de volta para bytes originais

#### **Implementa√ß√£o espec√≠fica no projeto**

```dart
// Processo completo de upload de imagem
Future<bool> processarImagem(XFile imagemFile) async {
  try {
    // 1. Leitura do arquivo
    final bytes = await imagemFile.readAsBytes();

    // 2. Valida√ß√£o de tamanho (max 5MB)
    if (bytes.length > 5 * 1024 * 1024) {
      throw Exception('Arquivo muito grande');
    }

    // 3. Compress√£o (se necess√°rio)
    final bytesOtimizados = await _comprimirSeNecessario(bytes);

    // 4. Codifica√ß√£o Base64
    final base64String = base64Encode(bytesOtimizados);

    // 5. Armazenamento no Firestore
    await _firestore.collection('postagens').add({
      'conteudo': 'Texto da postagem',
      'imagensBase64': [base64String],
      'timestamp': FieldValue.serverTimestamp(),
    });

    return true;
  } catch (e) {
    print('Erro no processamento: $e');
    return false;
  }
}

// Processo de recupera√ß√£o e exibi√ß√£o
Widget exibirImagem(String base64String) {
  try {
    // Decodifica√ß√£o Base64 para bytes
    final bytes = base64Decode(base64String);

    // Exibi√ß√£o direta na interface
    return Image.memory(
      bytes,
      fit: BoxFit.cover,
      errorBuilder: (context, error, stackTrace) {
        return Icon(Icons.error, color: Colors.red);
      },
    );
  } catch (e) {
    return Icon(Icons.broken_image, color: Colors.grey);
  }
}
```

#### **An√°lise comparativa: Base64 vs Firebase Storage**

| **Aspecto**             | **Base64 (Escolhido)**   | **Firebase Storage** |
| ----------------------- | ------------------------ | -------------------- |
| **Complexidade**        | Baixa (1 servi√ßo)        | M√©dia (2 servi√ßos)   |
| **Consist√™ncia**        | At√¥mica                  | Eventual             |
| **Overhead**            | +33% tamanho             | URLs pequenas        |
| **Cache**               | Autom√°tico (Firestore)   | Manual (CDN)         |
| **Limite tamanho**      | 1MB por documento        | 5TB por arquivo      |
| **Velocidade upload**   | R√°pida (direto)          | M√©dia (2 etapas)     |
| **Velocidade download** | Lenta (dados grandes)    | R√°pida (CDN)         |
| **Backup**              | Integrado                | Separado             |
| **Custo**               | Inclu√≠do no Firestore    | Adicional            |
| **Adequa√ß√£o**           | Arquivos pequenos/m√©dios | Arquivos grandes     |

#### **Otimiza√ß√µes implementadas**

**1. Compress√£o autom√°tica de imagens:**

```dart
Future<Uint8List> _comprimirImagem(Uint8List bytes) async {
  if (bytes.length <= 1024 * 1024) return bytes; // < 1MB: n√£o comprimir

  return await FlutterImageCompress.compressWithList(
    bytes,
    quality: 85, // Qualidade balanceada
    maxWidth: 1920, // Full HD m√°ximo
    maxHeight: 1920,
    format: CompressFormat.jpeg, // For√ßa JPEG (menor)
  );
}
```

**2. Valida√ß√£o de tamanho progressiva:**

```dart
bool _validarTamanhoDocumento(List<String> imagens, List<DocumentoModel> docs) {
  double tamanhoTotal = 0;

  // Calcular tamanho das imagens (Base64 overhead ~33%)
  for (final base64 in imagens) {
    tamanhoTotal += base64.length / (1024 * 1024);
  }

  // Calcular tamanho dos documentos
  for (final doc in docs) {
    tamanhoTotal += (doc.conteudoBase64.length / (1024 * 1024));
  }

  return tamanhoTotal <= 0.8; // 80% do limite Firestore (1MB)
}
```

**3. Estrat√©gia de fallback:**

```dart
Future<void> salvarPostagem(PostagemModel postagem) async {
  try {
    // Tentar salvar com todos os anexos
    await _firestore.collection('postagens').add(postagem.toMap());
  } catch (e) {
    if (e.toString().contains('document too large')) {
      // Fallback: reduzir qualidade das imagens
      final postagemOtimizada = await _otimizarAnexos(postagem);
      await _firestore.collection('postagens').add(postagemOtimizada.toMap());
    } else {
      rethrow;
    }
  }
}
```

#### **Justificativa da escolha no contexto educacional**

**1. Simplicidade arquitetural priorizada:**
Em ambiente acad√™mico/educacional, a simplicidade de desenvolvimento e manuten√ß√£o supera otimiza√ß√µes de performance para casos de uso espec√≠ficos.

**2. Volume de dados adequado:**
Aulas particulares geram volume limitado de anexos (exerc√≠cios, imagens de quadro, PDFs pequenos), adequado √†s limita√ß√µes do Base64.

**3. Facilidade de backup e migra√ß√£o:**
Institui√ß√µes educacionais valorizam facilidade de backup completo e migra√ß√£o de dados, favorecendo abordagem integrada.

**4. Redu√ß√£o de depend√™ncias:**
Menor n√∫mero de servi√ßos externos reduz pontos de falha e simplifica configura√ß√£o para novos desenvolvedores.

### **B.2 √çndices do Firestore**

#### **√çndices compostos necess√°rios**

**postagens:**

- professorId (ASC) + ativo (ASC) + dataPostagem (DESC)
- alunosDestino (ARRAY) + ativo (ASC) + dataPostagem (DESC)
- materia (ASC) + alunosDestino (ARRAY) + dataPostagem (DESC)

**aulas:**

- professorId (ASC) + ativo (ASC) + diaSemana (ASC)
- alunoId (ASC) + ativo (ASC) + diaSemana (ASC)
- professorId (ASC) + diaSemana (ASC) + horario (ASC)

**users:**

- tipo (ASC) + ativo (ASC) + dataCriacao (DESC)
- email (ASC) + ativo (ASC)

### **B.3 Regras de valida√ß√£o**

#### **Valida√ß√µes de dados**

**Usu√°rios:**

- Nome: obrigat√≥rio, m√≠nimo 2 caracteres
- Email: formato v√°lido, √∫nico no sistema
- Tipo: apenas "professor" ou "aluno"

**Postagens:**

- Conte√∫do: obrigat√≥rio, m√°ximo 5000 caracteres
- Mat√©ria: obrigat√≥ria, lista pr√©-definida
- Destinat√°rios: pelo menos um aluno

**Aulas:**

- Dia da semana: 0-6 (domingo a s√°bado)
- Hor√°rio: formato HH:mm v√°lido
- Conflitos: n√£o permitir sobreposi√ß√£o

#### **Valida√ß√µes de neg√≥cio**

**Relacionamentos:**

- Professor pode ter m√∫ltiplos alunos
- Aluno pode ter m√∫ltiplos professores
- Postagem deve ter destinat√°rios v√°lidos
- Aula deve ter participantes v√°lidos

**Permiss√µes:**

- Professor: CRUD em suas postagens e aulas
- Aluno: READ em postagens destinadas a ele
- Aluno: READ em aulas que participa

---

## **AP√äNDICE C - C√ìDIGO FONTE COMPLETO DOS MODELS**

### **C.1 UserModel**

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

enum TipoUsuario { professor, aluno }

class UserModel {
  final String id;
  final String nome;
  final String email;
  final TipoUsuario tipo;
  final bool ativo;
  final DateTime dataCriacao;
  final DateTime? ultimoAcesso;

  UserModel({
    required this.id,
    required this.nome,
    required this.email,
    required this.tipo,
    this.ativo = true,
    required this.dataCriacao,
    this.ultimoAcesso,
  });

  // Converter de Map (Firestore) para UserModel
  factory UserModel.fromMap(Map<String, dynamic> map, String documentId) {
    return UserModel(
      id: documentId,
      nome: map['nome'] ?? '',
      email: map['email'] ?? '',
      tipo: _stringToTipoUsuario(map['tipo'] ?? 'aluno'),
      ativo: map['ativo'] ?? true,
      dataCriacao: (map['dataCriacao'] as Timestamp).toDate(),
      ultimoAcesso: map['ultimoAcesso'] != null
          ? (map['ultimoAcesso'] as Timestamp).toDate()
          : null,
    );
  }

  // Converter de UserModel para Map (Firestore)
  Map<String, dynamic> toMap() {
    return {
      'nome': nome,
      'email': email,
      'tipo': _tipoUsuarioToString(tipo),
      'ativo': ativo,
      'dataCriacao': Timestamp.fromDate(dataCriacao),
      'ultimoAcesso': ultimoAcesso != null
          ? Timestamp.fromDate(ultimoAcesso!)
          : null,
    };
  }

  // Converter string para enum
  static TipoUsuario _stringToTipoUsuario(String tipo) {
    switch (tipo.toLowerCase()) {
      case 'professor':
        return TipoUsuario.professor;
      case 'aluno':
        return TipoUsuario.aluno;
      default:
        return TipoUsuario.aluno;
    }
  }

  // Converter enum para string
  static String _tipoUsuarioToString(TipoUsuario tipo) {
    switch (tipo) {
      case TipoUsuario.professor:
        return 'professor';
      case TipoUsuario.aluno:
        return 'aluno';
    }
  }

  // Validar email
  static bool isValidEmail(String email) {
    return RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(email);
  }

  // Validar nome
  static bool isValidName(String nome) {
    return nome.trim().length >= 2;
  }

  // CopyWith para atualiza√ß√µes
  UserModel copyWith({
    String? id,
    String? nome,
    String? email,
    TipoUsuario? tipo,
    bool? ativo,
    DateTime? dataCriacao,
    DateTime? ultimoAcesso,
  }) {
    return UserModel(
      id: id ?? this.id,
      nome: nome ?? this.nome,
      email: email ?? this.email,
      tipo: tipo ?? this.tipo,
      ativo: ativo ?? this.ativo,
      dataCriacao: dataCriacao ?? this.dataCriacao,
      ultimoAcesso: ultimoAcesso ?? this.ultimoAcesso,
    );
  }

  @override
  String toString() {
    return 'UserModel(id: $id, nome: $nome, email: $email, tipo: $tipo)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is UserModel && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}
```

### **C.2 PostagemModel**

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

class DocumentoModel {
  final String nome;
  final String tipo;
  final int tamanho;
  final String conteudoBase64;
  final DateTime dataUpload;

  DocumentoModel({
    required this.nome,
    required this.tipo,
    required this.tamanho,
    required this.conteudoBase64,
    required this.dataUpload,
  });

  factory DocumentoModel.fromMap(Map<String, dynamic> map) {
    return DocumentoModel(
      nome: map['nome'] ?? '',
      tipo: map['tipo'] ?? '',
      tamanho: map['tamanho'] ?? 0,
      conteudoBase64: map['conteudoBase64'] ?? '',
      dataUpload: (map['dataUpload'] as Timestamp).toDate(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'nome': nome,
      'tipo': tipo,
      'tamanho': tamanho,
      'conteudoBase64': conteudoBase64,
      'dataUpload': Timestamp.fromDate(dataUpload),
    };
  }
}

class VisualizacaoModel {
  final String alunoId;
  final DateTime dataVisualizacao;

  VisualizacaoModel({
    required this.alunoId,
    required this.dataVisualizacao,
  });

  factory VisualizacaoModel.fromMap(Map<String, dynamic> map) {
    return VisualizacaoModel(
      alunoId: map['alunoId'] ?? '',
      dataVisualizacao: (map['dataVisualizacao'] as Timestamp).toDate(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'alunoId': alunoId,
      'dataVisualizacao': Timestamp.fromDate(dataVisualizacao),
    };
  }
}

class PostagemModel {
  final String id;
  final String professorId;
  final String materia;
  final String titulo;
  final String conteudo;
  final List<String> alunosDestino;
  final DateTime dataPostagem;
  final List<String> imagensBase64;
  final List<DocumentoModel> documentos;
  final bool ativo;
  final List<VisualizacaoModel> visualizacoes;

  PostagemModel({
    required this.id,
    required this.professorId,
    required this.materia,
    this.titulo = '',
    required this.conteudo,
    required this.alunosDestino,
    required this.dataPostagem,
    this.imagensBase64 = const [],
    this.documentos = const [],
    this.ativo = true,
    this.visualizacoes = const [],
  });

  factory PostagemModel.fromMap(Map<String, dynamic> map, String documentId) {
    return PostagemModel(
      id: documentId,
      professorId: map['professorId'] ?? '',
      materia: map['materia'] ?? '',
      titulo: map['titulo'] ?? '',
      conteudo: map['conteudo'] ?? '',
      alunosDestino: List<String>.from(map['alunosDestino'] ?? []),
      dataPostagem: (map['dataPostagem'] as Timestamp).toDate(),
      imagensBase64: List<String>.from(map['imagensBase64'] ?? []),
      documentos: (map['documentos'] as List<dynamic>?)
          ?.map((doc) => DocumentoModel.fromMap(doc))
          .toList() ?? [],
      ativo: map['ativo'] ?? true,
      visualizacoes: (map['visualizacoes'] as List<dynamic>?)
          ?.map((vis) => VisualizacaoModel.fromMap(vis))
          .toList() ?? [],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'professorId': professorId,
      'materia': materia,
      'titulo': titulo,
      'conteudo': conteudo,
      'alunosDestino': alunosDestino,
      'dataPostagem': Timestamp.fromDate(dataPostagem),
      'imagensBase64': imagensBase64,
      'documentos': documentos.map((doc) => doc.toMap()).toList(),
      'ativo': ativo,
      'visualizacoes': visualizacoes.map((vis) => vis.toMap()).toList(),
    };
  }

  // Verificar se aluno visualizou a postagem
  bool foiVisualizadoPor(String alunoId) {
    return visualizacoes.any((vis) => vis.alunoId == alunoId);
  }

  // Adicionar visualiza√ß√£o
  PostagemModel adicionarVisualizacao(String alunoId) {
    if (foiVisualizadoPor(alunoId)) return this;

    final novaVisualizacao = VisualizacaoModel(
      alunoId: alunoId,
      dataVisualizacao: DateTime.now(),
    );

    return copyWith(
      visualizacoes: [...visualizacoes, novaVisualizacao],
    );
  }

  // Quantidade de anexos
  int get totalAnexos => imagensBase64.length + documentos.length;

  // Tamanho total em bytes
  int get tamanhoTotalBytes {
    int total = 0;

    // Aproxima√ß√£o para imagens base64 (75% do tamanho base64)
    for (final base64 in imagensBase64) {
      total += (base64.length * 0.75).round();
    }

    // Documentos
    for (final doc in documentos) {
      total += doc.tamanho;
    }

    return total;
  }

  PostagemModel copyWith({
    String? id,
    String? professorId,
    String? materia,
    String? titulo,
    String? conteudo,
    List<String>? alunosDestino,
    DateTime? dataPostagem,
    List<String>? imagensBase64,
    List<DocumentoModel>? documentos,
    bool? ativo,
    List<VisualizacaoModel>? visualizacoes,
  }) {
    return PostagemModel(
      id: id ?? this.id,
      professorId: professorId ?? this.professorId,
      materia: materia ?? this.materia,
      titulo: titulo ?? this.titulo,
      conteudo: conteudo ?? this.conteudo,
      alunosDestino: alunosDestino ?? this.alunosDestino,
      dataPostagem: dataPostagem ?? this.dataPostagem,
      imagensBase64: imagensBase64 ?? this.imagensBase64,
      documentos: documentos ?? this.documentos,
      ativo: ativo ?? this.ativo,
      visualizacoes: visualizacoes ?? this.visualizacoes,
    );
  }
}
```

---

### üìä **M√âTRICAS DOS AP√äNDICES**

| **Ap√™ndice**               | **Conte√∫do**                       | **Palavras**       |
| -------------------------- | ---------------------------------- | ------------------ |
| **A - Testes Usabilidade** | Protocolo completo + question√°rios | 1.567 palavras     |
| **B - Modelagem BD**       | Estrutura Firestore + valida√ß√µes   | 745 palavras       |
| **C - C√≥digo Models**      | C√≥digo fonte completo              | 1.234 palavras     |
| **TOTAL AP√äNDICES**        | **Documenta√ß√£o t√©cnica detalhada** | **3.546 palavras** |

---

**üìÑ Continua: Anexos**
